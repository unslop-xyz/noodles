<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>unslop overlay</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        margin: 0;
        padding: 12px;
        background: #f6f7fb;
        color: #1b1b1b;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }
      h1 {
        font-size: 16px;
        margin: 0 0 4px 0;
        text-align: center;
      }
      .info-btn {
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 24px;
        height: 24px;
        padding: 0;
        border: 1px solid #ccc;
        background: white;
        border-radius: 50%;
        cursor: help;
        font-size: 14px;
        color: #666;
        margin-left: 8px;
      }
      .info-btn:hover {
        border-color: #888;
        color: #333;
      }
      .info-tooltip {
        visibility: hidden;
        opacity: 0;
        position: absolute;
        top: 100%;
        right: 0;
        margin-top: 8px;
        width: 280px;
        padding: 12px;
        background: #333;
        color: #fff;
        border-radius: 6px;
        font-size: 12px;
        line-height: 1.5;
        text-align: left;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        transition: opacity 0.15s, visibility 0.15s;
      }
      .info-tooltip::before {
        content: '';
        position: absolute;
        bottom: 100%;
        right: 8px;
        border: 6px solid transparent;
        border-bottom-color: #333;
      }
      .info-btn:hover .info-tooltip,
      .info-btn:focus .info-tooltip {
        visibility: visible;
        opacity: 1;
      }
      .info-tooltip ul {
        margin: 0;
        padding: 0 0 0 16px;
      }
      .info-tooltip li {
        margin-bottom: 6px;
      }
      .info-tooltip li:last-child {
        margin-bottom: 0;
      }
      .info-tooltip kbd {
        display: inline-block;
        padding: 2px 6px;
        background: #555;
        border-radius: 3px;
        font-family: inherit;
        font-size: 11px;
      }
      .info-tooltip .d2-icon {
        display: inline-block;
        width: 18px;
        height: 18px;
        vertical-align: middle;
        margin-right: 4px;
      }
      .info-tooltip .d2-icon svg {
        width: 100%;
        height: 100%;
      }
      .row {
        display: flex;
        gap: 8px;
        margin-bottom: 8px;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
      }
      .model-label {
        font-size: 12px;
        color: #555;
      }
      .api-label {
        font-size: 12px;
        color: #555;
        margin-left: 6px;
      }
      .model-select {
        padding: 6px 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        background: #fff;
        font-size: 12px;
      }
      .api-input {
        padding: 6px 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        background: #fff;
        font-size: 12px;
        min-width: 160px;
      }
      .api-field {
        position: relative;
        display: inline-flex;
        align-items: center;
      }
      .api-field .api-input {
        padding-right: 22px;
      }
      .api-status {
        position: absolute;
        right: 6px;
        top: 50%;
        transform: translateY(-50%);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-left: 2px;
        user-select: none;
        pointer-events: none;
        z-index: 2;
        background: transparent;
        color: #fff;
        font-size: 9px;
        font-weight: 700;
        line-height: 1;
      }
      .api-status.valid {
        background: #2E8B57;
      }
      .api-status.invalid {
        background: #C2410C;
      }
      button {
        padding: 6px 10px;
        border: 1px solid #ccc;
        background: white;
        border-radius: 4px;
        cursor: pointer;
      }
      button:hover { border-color: #888; }
      #diagram-frame {
        position: relative;
        border: 1px solid #ccc;
        border-radius: 6px;
        background: #fff;
        flex: 0 0 auto;
        height: calc(100vh - 150px);
        min-height: 0;
        overflow: hidden;
        margin-top: 4px;
        margin-bottom: 12px;
      }
      #diagram-progress {
        height: 10px;
        border-radius: 999px;
        background: #eceef4;
        overflow: hidden;
        margin: 0 6px 10px;
        opacity: 0;
        transition: opacity 0.2s ease;
      }
      #diagram-progress.active {
        opacity: 1;
      }
      #diagram-progress-bar {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #7aa2ff, #5c7cfa);
        transition: width 0.2s ease;
      }
      #diagram-inner {
        width: 100%;
        height: 100%;
        overflow: auto;
      }
      #diagram-img {
        transform-origin: top left;
        user-select: none;
        -webkit-user-drag: none;
        max-width: none;
        display: none;
      }
      #diagram-svg {
        transform-origin: top left;
        user-select: none;
        max-width: none;
        display: none;
        padding: 8px;
      }
      #diagram-svg svg {
        display: block;
        transform-origin: top left;
      }
      #diagram-svg .unslop-hover {
        filter: drop-shadow(0 0 6px rgba(255, 140, 0, 0.5));
      }
      #diagram-log {
        text-align: left;
        font-size: 11px;
        color: #555;
        min-height: 36px;
        display: block;
        padding: 20px 8px 6px;
        border: 1px solid #ddd;
        border-radius: 8px;
        background: #fafafa;
        overflow-y: auto;
        overflow-x: hidden;
        position: relative;
      }
      #diagram-log-timer {
        position: absolute;
        top: 6px;
        right: 8px;
        font-size: 11px;
        color: #888;
        font-variant-numeric: tabular-nums;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 2px;
      }
      .diagram-log-timer-row {
        display: flex;
        gap: 6px;
      }
      .diagram-log-timer-label {
        color: #666;
      }
      #diagram-log-text {
        display: block;
        white-space: pre-wrap;
        line-height: 1.4;
      }
      #diagram-log-text .log-line {
        margin: 0 0 4px 0;
      }
    </style>
  </head>
  <body>
    <div class="row">
      <button onclick="chooseFolder()">Choose folder…</button>
      <button onclick="updateDiagram()">Update</button>
      <button onclick="rerun()">Rerun</button>
      <span class="model-label">Model</span>
      <select id="overview-model" class="model-select" aria-label="Overview model">
        <option value="gpt-4.1" selected>gpt-4.1</option>
        <option value="gpt-5-mini">gpt-5-mini</option>
      </select>
      <span class="api-label">OpenAI API key</span>
      <span class="api-field">
        <input id="openai-key" class="api-input" type="text" placeholder="Not set" />
        <span id="openai-key-status" class="api-status" aria-live="polite"></span>
      </span>
      <button class="info-btn" aria-label="Help" tabindex="0">
        <span aria-hidden="true">?</span>
        <div class="info-tooltip" role="tooltip">
          <ul>
            <li><span class="d2-icon"><svg viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M16 31.1109C24.3456 31.1109 31.1111 24.3454 31.1111 15.9998C31.1111 7.65415 24.3456 0.888672 16 0.888672C7.65436 0.888672 0.888885 7.65415 0.888885 15.9998C0.888885 24.3454 7.65436 31.1109 16 31.1109Z" fill="white" stroke="#DEE1EB"/><path d="M14.3909 16.7965C14.7364 17.2584 15.1772 17.6406 15.6834 17.9171C16.1896 18.1938 16.7494 18.3582 17.3248 18.3993C17.9001 18.4405 18.4777 18.3575 19.0181 18.1559C19.5586 17.9543 20.0492 17.6389 20.4571 17.2309L22.8708 14.8173C23.6036 14.0586 24.0089 13.0425 23.9998 11.9877C23.9906 10.933 23.5676 9.92404 22.8217 9.17821C22.0759 8.43237 21.067 8.00931 20.0123 8.00015C18.9575 7.99098 17.9413 8.39644 17.1827 9.1292L15.7988 10.505" stroke="#2E3346" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M17.609 15.1874C17.2635 14.7255 16.8227 14.3433 16.3165 14.0667C15.8103 13.7902 15.2505 13.6257 14.6752 13.5845C14.0998 13.5433 13.5223 13.6263 12.9819 13.8279C12.4414 14.0295 11.9506 14.345 11.5428 14.753L9.1292 17.1666C8.39644 17.9252 7.99098 18.9414 8.00015 19.9962C8.00931 21.0509 8.43237 22.0598 9.17821 22.8056C9.92405 23.5515 10.933 23.9745 11.9877 23.9837C13.0425 23.9928 14.0586 23.5875 14.8173 22.8547L16.193 21.4788" stroke="#2E3346" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></span> node is clickable, click to view details</li>
            <li><span class="d2-icon"><svg viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M16 31.1109C24.3456 31.1109 31.1111 24.3454 31.1111 15.9998C31.1111 7.65415 24.3456 0.888672 16 0.888672C7.65436 0.888672 0.888885 7.65415 0.888885 15.9998C0.888885 24.3454 7.65436 31.1109 16 31.1109Z" fill="white" stroke="#DEE1EB"/><path d="M16 26C21.5228 26 26 21.5228 26 16C26 10.4772 21.5228 6 16 6C10.4772 6 6 10.4772 6 16C6 21.5228 10.4772 26 16 26Z" stroke="#2E3346" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16 19.998V15.998" stroke="#2E3346" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16 12H16.0098" stroke="#2E3346" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></span> hover to see tooltips</li>
            <li><span style="color:#2E8B57">Green</span> stroke indicates an added node</li>
            <li><span style="color:#D97706">Orange</span> stroke indicates an updated node</li>
            <li>Press <kbd>Esc</kbd> to return to the previous diagram</li>
            <li>Double-press <kbd>Esc</kbd> to return to the main diagram</li>
            <li>Use <kbd>Ctrl</kbd> + scroll to zoom, or use trackpad</li>
          </ul>
        </div>
      </button>
    </div>

    <div id="diagram-frame">
      <div id="diagram-inner">
        <div id="diagram-svg" aria-live="polite"></div>
        <img id="diagram-img" alt="" />
      </div>
    </div>
    <div id="diagram-progress" aria-hidden="true">
      <div id="diagram-progress-bar"></div>
    </div>
    <div id="diagram-log">
      <div id="diagram-log-timer" aria-live="off">
        <div class="diagram-log-timer-row">
          <span class="diagram-log-timer-label">Overview</span>
          <span id="diagram-log-timer-overview">0.0s</span>
        </div>
        <div class="diagram-log-timer-row">
          <span class="diagram-log-timer-label">Node</span>
          <span id="diagram-log-timer-node">0.0s</span>
        </div>
      </div>
      <div id="diagram-log-text" aria-live="polite"></div>
    </div>

    <script>
      let zoom = 1;
      const zoomStep = 1.15;
      const inner = document.getElementById('diagram-inner');
      const svgContainer = document.getElementById('diagram-svg');
      const img = document.getElementById('diagram-img');
      const logTextEl = document.getElementById('diagram-log-text');
      const logTimerOverviewEl = document.getElementById('diagram-log-timer-overview');
      const logTimerNodeEl = document.getElementById('diagram-log-timer-node');
      const overviewModelEl = document.getElementById('overview-model');
      const openaiKeyEl = document.getElementById('openai-key');
      const openaiKeyStatusEl = document.getElementById('openai-key-status');
      const progressWrap = document.getElementById('diagram-progress');
      const progressBar = document.getElementById('diagram-progress-bar');
      const loadingStates = { overview: false, node: false };
      let svgEl = null;
      let hoverTarget = null;
      let lastOverviewPayload = null;
      let lastOverviewPath = '';
      let currentDiagramPayload = null;
      const diagramHistory = [];
      let escTimer = null;
      let lastEscTime = 0;
      const escDoubleThresholdMs = 200;
      const timerState = {
        overview: { start: 0, interval: null, el: null, lastElapsed: 0 },
        node: { start: 0, interval: null, el: null, lastElapsed: 0 },
      };
      let progressTimer = null;
      let progressValue = 0;
      let progressPhase = 'idle';
      let progressStart = 0;
      let progressTargetMs = 0;
      let progressPauseUntil = 0;

      let isPanning = false;
      let startX = 0;
      let startY = 0;
      let scrollLeft = 0;
      let scrollTop = 0;
      let touchActive = false;
      let lastTouchCenter = null;
      let lastTouchDistance = null;
      const pinchThreshold = 4;

      inner.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return;
        isPanning = true;
        startX = e.pageX - inner.offsetLeft;
        startY = e.pageY - inner.offsetTop;
        scrollLeft = inner.scrollLeft;
        scrollTop = inner.scrollTop;
      });
      inner.addEventListener('mouseleave', () => stopPan());
      inner.addEventListener('mouseup', () => stopPan());
      inner.addEventListener('mousemove', (e) => {
        if (!isPanning) return;
        e.preventDefault();
        const x = e.pageX - inner.offsetLeft;
        const y = e.pageY - inner.offsetTop;
        const walkX = (x - startX);
        const walkY = (y - startY);
        inner.scrollLeft = scrollLeft - walkX;
        inner.scrollTop = scrollTop - walkY;
      });

      function stopPan() {
        isPanning = false;
      }

      function getTouchCenter(touches) {
        const x = (touches[0].clientX + touches[1].clientX) / 2;
        const y = (touches[0].clientY + touches[1].clientY) / 2;
        return { x, y };
      }

      function getTouchDistance(touches) {
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        return Math.hypot(dx, dy);
      }

      function applyZoom() {
        if (svgEl) {
          svgEl.style.width = `${zoom * 100}%`;
          svgEl.style.height = 'auto';
          svgEl.style.transform = 'none';
          return;
        }
        const kind = img.dataset.kind || 'raster';
        if (kind === 'svg') {
          img.style.transform = 'none';
          img.style.width = `${zoom * 100}%`;
          img.style.height = 'auto';
        } else {
          img.style.width = '';
          img.style.height = '';
          img.style.transform = `scale(${zoom})`;
        }
      }

      function clearDiagram() {
        svgContainer.innerHTML = '';
        svgContainer.style.display = 'none';
        img.removeAttribute('src');
        img.dataset.kind = '';
        img.style.display = 'none';
        svgEl = null;
      }

      function setDiagram(svgText) {
        svgContainer.innerHTML = svgText || '';
        svgEl = svgContainer.querySelector('svg');
        if (!svgEl) {
          svgContainer.innerHTML = '';
          svgContainer.style.display = 'none';
          svgEl = null;
          return;
        }
        svgContainer.style.display = 'block';
        img.style.display = 'none';
        svgEl.setAttribute('focusable', 'false');
        applyZoom();
        attachSvgInteractions();
      }

      function setImage(src) {
        svgContainer.innerHTML = '';
        svgContainer.style.display = 'none';
        svgEl = null;
        img.src = src;
        img.dataset.kind = 'svg';
        img.style.display = 'block';
        applyZoom();
      }

      function getInteractiveGroup(target) {
        let el = target;
        while (el && el !== svgEl) {
          if (el.tagName) {
            const tag = el.tagName.toLowerCase();
            const link = tag === 'a' ? el : el.closest('a');
            const href = link ? (link.getAttribute('href') || link.getAttribute('xlink:href')) : null;
            if (tag === 'g') {
              const title = el.querySelector('title');
              if (title || href) return { group: el, title, href };
            }
            if (tag === 'a' && href) {
              return { group: el, title: el.querySelector('title'), href };
            }
          }
          el = el.parentElement;
        }
        return null;
      }

      function extractNodeId(href, titleText) {
        if (!href) return '';
        const match = href.match(/^unslop:\/\/node\/(.+)$/);
        return match ? match[1] : '';
      }

      function setHoverTarget(group) {
        if (hoverTarget === group) return;
        if (hoverTarget) hoverTarget.classList.remove('unslop-hover');
        hoverTarget = group;
        if (hoverTarget) hoverTarget.classList.add('unslop-hover');
      }

      function attachSvgInteractions() {
        if (!svgEl) return;
        svgEl.addEventListener('mousemove', (event) => {
          const hit = getInteractiveGroup(event.target);
          if (hit) {
            setHoverTarget(hit.group);
            // Hover highlight only; no status text.
          } else {
            setHoverTarget(null);
          }
        });
        svgEl.addEventListener('mouseleave', () => {
          setHoverTarget(null);
        });
        svgEl.addEventListener('click', (event) => {
          const hit = getInteractiveGroup(event.target);
          if (!hit) return;
          const nodeId = extractNodeId(hit.href);
          if (!nodeId) return;
          loadNodeDiagram(nodeId);
        });
      }

      function setZoom(value, anchor) {
        const clamped = Math.max(0.1, Math.min(value, 10));
        if (clamped === zoom) return;
        const prevZoom = zoom;
        zoom = clamped;
        applyZoom();
        if (anchor) {
          const scale = zoom / prevZoom;
          inner.scrollLeft = (anchor.x + inner.scrollLeft) * scale - anchor.x;
          inner.scrollTop = (anchor.y + inner.scrollTop) * scale - anchor.y;
        }
      }
      function zoomIn() { setZoom(zoom * zoomStep); }
      function zoomOut() { setZoom(zoom / zoomStep); }
      function resetZoom() {
        setZoom(1);
        inner.scrollTop = 0;
        inner.scrollLeft = 0;
      }

      inner.addEventListener('wheel', (e) => {
        if (!e.ctrlKey) return;
        if (!svgEl && !img.src) return;
        e.preventDefault();
        const rect = inner.getBoundingClientRect();
        const anchor = { x: e.clientX - rect.left, y: e.clientY - rect.top };
        const factor = Math.pow(zoomStep, -e.deltaY / 40);
        setZoom(zoom * factor, anchor);
      }, { passive: false });

      inner.addEventListener('touchstart', (e) => {
        if (e.touches.length !== 2) return;
        touchActive = true;
        lastTouchCenter = getTouchCenter(e.touches);
        lastTouchDistance = getTouchDistance(e.touches);
      }, { passive: false });

      inner.addEventListener('touchmove', (e) => {
        if (!touchActive || e.touches.length !== 2) return;
        if (!svgEl && !img.src) return;
        e.preventDefault();
        const center = getTouchCenter(e.touches);
        const distance = getTouchDistance(e.touches);
        const rect = inner.getBoundingClientRect();
        const anchor = { x: center.x - rect.left, y: center.y - rect.top };
        if (lastTouchDistance) {
          const delta = Math.abs(distance - lastTouchDistance);
          if (delta >= pinchThreshold) {
            const factor = distance / lastTouchDistance;
            setZoom(zoom * factor, anchor);
          }
        }
        if (lastTouchCenter) {
          const dx = center.x - lastTouchCenter.x;
          const dy = center.y - lastTouchCenter.y;
          inner.scrollLeft -= dx;
          inner.scrollTop -= dy;
        }
        lastTouchCenter = center;
        lastTouchDistance = distance;
      }, { passive: false });

      inner.addEventListener('touchend', (e) => {
        if (e.touches.length < 2) {
          touchActive = false;
          lastTouchCenter = null;
          lastTouchDistance = null;
        }
      });

      document.addEventListener('keydown', (e) => {
        if (e.key !== 'Escape') return;
        const now = Date.now();
        if (now - lastEscTime <= escDoubleThresholdMs) {
          if (escTimer) {
            clearTimeout(escTimer);
            escTimer = null;
          }
          lastEscTime = 0;
          renderOverviewDiagram();
          return;
        }
        lastEscTime = now;
        if (escTimer) {
          clearTimeout(escTimer);
        }
        escTimer = setTimeout(() => {
          escTimer = null;
          renderPreviousDiagram();
        }, escDoubleThresholdMs + 20);
      });

      async function chooseFolder() {
        try {
          const hasKey = await ensureOpenAIKey();
          if (!hasKey) return;
          const res = await window.pywebview.api.choose_folder(getOverviewModel());
          if (res?.error) logMessage(res.error);
          else if (res?.selected) {
            logMessage(`Selected: ${res.selected}`);
            fetchOpenAIKey();
          }
        } catch (e) {
          logMessage(String(e));
        }
      }
      async function rerun() {
        try {
          const res = await window.pywebview.api.rerun(getOverviewModel());
          if (res?.error) logMessage(res.error);
          else if (res?.selected) logMessage(`Rerunning for ${res.selected}`);
        } catch (e) {
          logMessage(String(e));
        }
      }
      async function updateDiagram() {
        try {
          const res = await window.pywebview.api.update(getOverviewModel());
          if (res?.error) logMessage(res.error);
          else if (res?.selected) logMessage(`Updating ${res.selected}`);
        } catch (e) {
          logMessage(String(e));
        }
      }
      function getOverviewModel() {
        return (overviewModelEl && overviewModelEl.value) ? overviewModelEl.value : 'gpt-4.1';
      }
      function logMessage(text) {
        if (!text) return;
        console.log(`[unslop overlay] ${text}`);
        if (!logTextEl) return;
        const line = document.createElement('div');
        line.className = 'log-line';
        line.textContent = text;
        logTextEl.appendChild(line);
        logTextEl.parentElement.scrollTop = logTextEl.parentElement.scrollHeight;
      }

      function formatElapsed(elapsedMs, active) {
        if (!active && elapsedMs <= 0) return '0.0s';
        const clampedMs = active ? Math.max(elapsedMs, 1000) : elapsedMs;
        const totalSeconds = clampedMs / 1000;
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        if (minutes > 0) {
          return `${minutes}:${seconds.toFixed(1).padStart(4, '0')}`;
        }
        return `${seconds.toFixed(1)}s`;
      }

      function updateTimerDisplay(scope) {
        const state = timerState[scope];
        if (!state || !state.el) return;
        const active = Boolean(loadingStates[scope]);
        const elapsed = active ? Date.now() - state.start : state.lastElapsed;
        state.el.textContent = formatElapsed(elapsed, active);
      }

      function startTimer(scope) {
        const state = timerState[scope];
        if (!state || !state.el || state.interval) return;
        state.start = Date.now();
        updateTimerDisplay(scope);
        state.interval = setInterval(() => {
          updateTimerDisplay(scope);
        }, 100);
      }

      function stopTimer(scope) {
        const state = timerState[scope];
        if (!state) return;
        if (state.interval) {
          clearInterval(state.interval);
          state.interval = null;
        }
        if (state.start) {
          state.lastElapsed = Math.max(0, Date.now() - state.start);
        }
        updateTimerDisplay(scope);
      }

      function setLoading(scope, active) {
        if (!scope || !(scope in loadingStates)) return;
        loadingStates[scope] = Boolean(active);
        if (loadingStates[scope]) {
          startTimer(scope);
          if (scope === 'overview') startProgress();
        } else {
          stopTimer(scope);
          if (scope === 'overview') markProgressWaiting();
        }
      }

      timerState.overview.el = logTimerOverviewEl;
      timerState.node.el = logTimerNodeEl;
      updateTimerDisplay('overview');
      updateTimerDisplay('node');
      fetchOpenAIKey();
      attachOpenAIKeyHandlers();

      async function fetchOpenAIKey(retries = 5) {
        if (!openaiKeyEl) return;
        const api = window.pywebview?.api;
        if (!api?.get_openai_key) {
          if (retries > 0) {
            setTimeout(() => fetchOpenAIKey(retries - 1), 300);
          }
          return;
        }
        try {
          const res = await api.get_openai_key();
          openaiKeyEl.value = res?.key || '';
          setApiKeyStatus('');
        } catch (e) {
          openaiKeyEl.value = '';
          setApiKeyStatus('');
        }
      }

      async function ensureOpenAIKey() {
        const api = window.pywebview?.api;
        if (!api?.get_openai_key) {
          window.alert('OpenAI API key is required to generate diagrams.');
          return false;
        }
        try {
          const res = await api.get_openai_key();
          const key = (res?.key || '').trim();
          if (!key) {
            window.alert('OpenAI API key is missing. Please enter it above before choosing a folder.');
            if (openaiKeyEl) openaiKeyEl.focus();
            return false;
          }
          return true;
        } catch (e) {
          window.alert('OpenAI API key is missing. Please enter it above before choosing a folder.');
          if (openaiKeyEl) openaiKeyEl.focus();
          return false;
        }
      }

      function attachOpenAIKeyHandlers() {
        if (!openaiKeyEl) return;
        openaiKeyEl.addEventListener('input', () => {
          setApiKeyStatus('');
        });
        openaiKeyEl.addEventListener('keydown', (event) => {
          if (event.key !== 'Enter') return;
          event.preventDefault();
          saveOpenAIKey();
        });
        openaiKeyEl.addEventListener('blur', () => {
          saveOpenAIKey();
        });
      }

      async function saveOpenAIKey() {
        const api = window.pywebview?.api;
        if (!openaiKeyEl || !api?.set_openai_key) return;
        const value = openaiKeyEl.value || '';
        try {
          const res = await api.set_openai_key(value);
          if (res?.cleared) {
            logMessage('OpenAI API key cleared for this session.');
          } else if (res?.key) {
            logMessage('OpenAI API key updated for this session.');
          }
          if (res?.env_written && res?.env_path) {
            logMessage(`Saved OpenAI API key to ${res.env_path}`);
          }
        } catch (e) {
          logMessage('Failed to update OpenAI API key.');
        }
      }

      function setApiKeyStatus(status) {
        if (!openaiKeyStatusEl) return;
        openaiKeyStatusEl.classList.remove('valid', 'invalid');
        if (status === 'valid') {
          openaiKeyStatusEl.textContent = '✓';
          openaiKeyStatusEl.setAttribute('title', 'API key valid');
          openaiKeyStatusEl.classList.add('valid');
        } else if (status === 'invalid') {
          openaiKeyStatusEl.textContent = '✕';
          openaiKeyStatusEl.setAttribute('title', 'API key invalid');
          openaiKeyStatusEl.classList.add('invalid');
        } else {
          openaiKeyStatusEl.textContent = '';
          openaiKeyStatusEl.removeAttribute('title');
        }
      }

      function setProgress(value) {
        if (!progressBar) return;
        progressValue = Math.max(0, Math.min(value, 100));
        progressBar.style.width = `${progressValue}%`;
      }

      function startProgress() {
        if (!progressWrap || !progressBar) return;
        progressPhase = 'running';
        progressValue = 0;
        progressStart = Date.now();
        progressTargetMs = 180000 + Math.random() * 120000;
        progressPauseUntil = 0;
        setProgress(0);
        progressWrap.classList.add('active');
        if (progressTimer) clearInterval(progressTimer);
        progressTimer = setInterval(tickProgress, 120);
      }

      function tickProgress() {
        if (progressValue >= 90) return;
        const now = Date.now();
        if (now < progressPauseUntil) return;
        if (Math.random() < 0.08) {
          progressPauseUntil = now + 300 + Math.random() * 900;
          return;
        }
        const elapsed = Math.max(0, now - progressStart);
        const ratio = Math.min(elapsed / Math.max(progressTargetMs, 1), 1);
        const eased = 1 - Math.pow(1 - ratio, 2);
        let desired = 90 * eased;
        if (progressPhase === 'waiting') {
          desired = Math.min(desired, 88);
        }
        const jitter = (Math.random() - 0.5) * 1.5;
        const nextValue = Math.min(90, Math.max(progressValue, desired + jitter));
        setProgress(nextValue);
      }

      function markProgressWaiting() {
        if (progressPhase === 'running') {
          progressPhase = 'waiting';
        }
      }

      function completeProgress() {
        if (!progressWrap || !progressBar) return;
        if (progressTimer) {
          clearInterval(progressTimer);
          progressTimer = null;
        }
        setProgress(100);
        setTimeout(() => {
          resetProgress();
        }, 350);
      }

      function resetProgress() {
        if (progressTimer) {
          clearInterval(progressTimer);
          progressTimer = null;
        }
        progressPhase = 'idle';
        progressValue = 0;
        if (progressWrap) {
          progressWrap.classList.remove('active');
        }
        setProgress(0);
      }

      function applyDiagramPayload(payload) {
        if (!payload) return;
        logMessage(payload.error || '');
        if (payload.error) {
          resetProgress();
        }
        if (payload.svg_inline) {
          setDiagram(payload.svg_inline);
          resetZoom();
          currentDiagramPayload = payload;
          if (payload.path && payload.path.endsWith('overview.d2')) {
            completeProgress();
          }
          return;
        }
        if (payload.svg) {
          setImage(payload.svg);
          resetZoom();
          currentDiagramPayload = payload;
          if (payload.path && payload.path.endsWith('overview.d2')) {
            completeProgress();
          }
          return;
        }
        if (payload.error) {
          currentDiagramPayload = payload;
          return;
        }
        clearDiagram();
        resetZoom();
        currentDiagramPayload = payload;
      }

      async function loadNodeDiagram(nodeId) {
        if (!lastOverviewPath) {
          console.warn('[unslop overlay] No overview diagram path available.');
          return;
        }
        if (currentDiagramPayload) {
          diagramHistory.push(currentDiagramPayload);
        }
        try {
          const res = await window.pywebview.api.load_node_diagram(nodeId, lastOverviewPath);
          if (res?.error) {
            if (res.missing) {
              logMessage(`Generating node diagram for ${res.node_id || nodeId}. Please wait...`);
            } else {
              logMessage(res.error);
            }
            return;
          }
          applyDiagramPayload(res);
        } catch (e) {
          logMessage(String(e));
        }
      }

      function renderOverviewDiagram() {
        if (!lastOverviewPayload) {
          logMessage('No overview diagram cached.');
          return;
        }
        diagramHistory.length = 0;
        applyDiagramPayload(lastOverviewPayload);
      }

      function renderPreviousDiagram() {
        if (!diagramHistory.length) {
          logMessage('No previous diagram cached.');
          return;
        }
        const prev = diagramHistory.pop();
        applyDiagramPayload(prev);
      }
      
      window.__unslopUpdate = (payload) => {
        if (!payload) return;
        if (payload.type === 'loading') {
          setLoading(payload.scope, payload.active);
          return;
        }
        if (payload.type === 'api_key_status') {
          setApiKeyStatus(payload.status || '');
          logMessage(`API key status: ${payload.status || 'unknown'}`);
          return;
        }
        if (payload.type === 'log') {
          logMessage(payload.message || '');
          const msg = payload.message || '';
          if (msg.startsWith('ERROR:') || msg.includes('OpenAI request failed')) {
            resetProgress();
          }
          return;
        }
        if (payload.type === 'warning') {
          logMessage(payload.message || '');
          resetProgress();
          return;
        }
        if (payload.type === 'diagram') {
          if (payload.path && payload.path.endsWith('overview.d2')) {
            lastOverviewPayload = payload;
            lastOverviewPath = payload.path;
          }
          applyDiagramPayload(payload);
        }
      };
    </script>
  </body>
</html>
